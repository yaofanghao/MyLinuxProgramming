<!--
 * @Author: yao fanghao
 * @Date: 2023-04-14 22:13:52
 * @LastEditTime: 2023-06-03 11:07:19
 * @LastEditors: yao fanghao
-->

# 参考资料

* **CSAPP**
* **操作系统导论OSTEP**
* **APUE**
* https://stevens.netmeister.org/631/
* 软件调试
* 王道-操作系统
* 操作系统真象还原
* 小林coding-图解系统
* https://xiaolincoding.com/
* 嵌入式软件开发笔试面试指南
* Linux是怎样工作的 √
* [[过期] 2020 南京大学 “操作系统：设计与实现” (蒋炎岩)] <https://www.bilibili.com/video/BV1N741177F5/>
* 【彻底搞懂 进程&线程、进程池&线程池】 <https://www.bilibili.com/video/BV1V84y1Y77s/>

# 操作系统概念

* 特点
  * 并发
  * 共享
  * 虚拟
  * 异步

* Linux
  * 多任务、SMP对称多处理、ELF可执行文件、宏内核
* Windows
  * NT、PE可执行文件、混合型内核

# 进程与线程

## -进程

* 进程的状态
  * 运行台 就绪态 阻塞态（等待态） 创建态 终止态
  * ![1](_img/OS/process.png "进程状态")  
  
* 进程控制块 PCB
  * **PCB 是进程存在的唯一标志**

* 并发：交替进行
* 并行：同时进行 --流水线

## -线程

* 线程间可以并发运行且共享相同的地址空间
* 进程中一个线程崩溃，其他线程都崩溃
* **线程是调度的基本单位，进程是资源拥有的基本单位**

* 线程的实现
  * 用户线程的整个线程管理和调度，操作系统不直接参与
  * 用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等
  * 内核线程由操作系统管理程对应的TCB放在操作系统
  * 内核线程的创建、终止和管理都由操作系统负责
  * 轻量级线程 LWP

## -进程调度算法

* **需要考虑的因素**
  * CPU利用率
  * 吞吐量。长作业会降低吞吐量
  * 周转时间。进程运行和阻塞时间的总和
  * 等待时间。进程处于就绪队列的时间
  * 响应时间。交互式系统中衡量调度算法的主要标准

* FCFS 先来先服务调度算法
  * 不可剥夺
  * 效率低，适用于CPU繁忙型作业
  * 对长作业有利，对短作业不利
  
* SJF 短作业优先调度算法
  * 对短作业有利
  * 相比FCFS降低了平均周转时间
  * 可能会导致长作业“饥饿”现象
  
* 优先级调度算法
  * 分为非抢占式和抢占式
  * 优先级设置规则：
    * 系统进程>用户进程 交互型>非交互型 I/O型>计算型
  
* RR 时间片轮转调度算法
  * 适用于分时系统，提高交互体验
  * 选择适当的时间片很重要
  
* MLFQ **多级反馈队列调度算法**
  * ![1](_img/OS/MFQ.png "MFQ") 
  * 动态调整优先级和时间片大小
  * **多个就绪队列，每个队列不同优先级**
  * **每个队列进程运行时间片不同**
  * **每个队列采用FCFS算法**
  * **按队列优先级调度**
  * 优点：短作业优先，周转时间短，长作业不会饿死

## -协程

* 是一种比线程更加轻量级的存在
* 正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程
* 协程不被操作系统内核所管理，而是**完全由程序所控制**（也就是在用户态执行）
* 协程的优点是性能得到了很大的提升，不像线程切换那样消耗资源

# 进程间通信 IPC

## -管道

* 管道是内核中的一串缓存，无格式且大小受限
* 一次性操作，只支持半双工
* 生产者消费者模式

* 匿名管道。Linux命令行中的 "|"
  * **只能用于父子关系的进程间通信**
* 命名管道。**FIFO**
  
  ```shell
  mkfifo myPipe
  echo "hello" > myPipe
  cat < myPipe
  ```
  
  ![1](_img/OS/fifo.png "fifo")

## -消息队列

* 消息队列是内核中的消息链表
* 不适合大数据传输

## -共享内存

* 共享内存的机制是拿出一块虚拟地址空间，映射到相同的物理内存中
  
## -信号量

* 信号量是一个整型的计数器
* 用于实现进程间的**互斥与同步**
* **P、V 操作**
  * P操作使得信号量减1
  * V操作使得信号量加1

## -信号

* 可参考APUE第10章
* 唯一的异步通信机制
* 两种无法捕捉和忽略的信号：SIGKILL、SEGSTOP

## -Socket

```c
int socket(int domain, int type, int protocal) 
```

* 字节流SOCKSTREAM、数据包SOCKDGRAM

* 基于TCP协议的通信示例：
  ![1](_img/OS/tcp_socket.png "socket")

* 1.服务端和客户端初始化socket，得到文件描述符
* 2.服务端调用bind，绑定IP和端口
* 3.服务端调用listen，开始监听
* 4.服务端调用accept，等待客户端连接
* 5.客户端调用connect，向服务端IP和端口发起连接请求
* 6.服务端调用accept，返回用于传输的socket文件描述符
* 7.客户端调用write写入数据
* 8.服务端调用read读取数据
* 9.客户端断开连接时，调用close，那么服务端read读取数据的时候，会读到EOF，待处理完数据后，服务端调用 close，表示连接关闭
* 这里需要注意的是，服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。

# 多线程同步

* 多个线程如果竞争共享资源，如果不采取有效的措施，则会造成共享数据的混乱
* 竞争条件。不确定性
* **临界区**

## -互斥与同步

* 同步举例：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等
* 互斥举例：「操作 A 和操作 B 不能在同一时刻执行」

* **锁**
  * 原子操作指令 —— 测试和置位（Test-and-Set）
  
  ```c
  int TestAndSet(int *old_ptr, int new)
  {
    int old = *old_ptr;
    *old_ptr = new;
    return old;
  }
  ```

  * **忙等待锁**。也称为自旋锁
  * 无等待锁。

* **信号量**
  
  * P/V操作
  
  ```c
  // 信号量数据结构
  type struct sem_t{
    int sem;  // 资源个数
    queue_t *q;  // 等待队列
  } sem_t;

  // 初始化信号量
  void init(sem_t *s, int sem)
  {
    s->sem = sem;
    queue_init(s->q);
  }

  // P操作
  void P(sem_t *s)
  {
    s->sem--;
    if(s->sem < 0)
    {
      // 1、保留调用线程CPU现场
      // 2、将该线程的TCB插入s的等待队列
      // 3、设置该线程为等待状态
      // 4、执行调度程序
    }
  }
      
  // V操作
  void V(sem_t *s)
  {
    s->sem++;
    if(s->sem <= 0)
    {
      // 1、移除s等待队列首元素
      // 2、将该线程的TCB插入就绪队列
      // 3、设置该线程为就绪状态
    }
  }
  ```

  * 对于两个并发线程，互斥信号量的值仅取 1、0 和 -1 三个值
  * **如果互斥信号量为 1，表示没有线程进入临界区**
  * **如果互斥信号量为 0，表示有一个线程进入临界区**
  * **如果互斥信号量为 -1，表示一个线程进入临界区，另一个线程等待进入**
  * 通过互斥信号量的方式，能保证临界区任何时刻只有一个线程在执行，就达到了互斥的效果。

## -生产者-消费者问题

* 问题描述：
  * 生产者在生成数据后，放在一个缓冲区中
  * 消费者从缓冲区取出数据处理
  * 任何时刻，只能有一个生产者或消费者可以访问缓冲区

* 互斥与同步的体现：
  * 任何时刻只能有一个线程操作缓冲区，说明操作缓冲区是临界代码，需要互斥
  * 缓冲区空时，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明生产者和消费者需要同步

* 需要三个信号量：
  * **互斥信号量 mutex**：用于互斥访问缓冲区，初始化值为 1
  * **资源信号量 fullBuffers**：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）；
  * **资源信号量 emptyBuffers**：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n （缓冲区大小）

## -哲学家就餐问题

* 用一个数组 state 来记录每一位哲学家在进程、思考还是饥饿状态（正在试图拿叉子）
* https://leetcode.cn/problems/the-dining-philosophers/description/

## -读写者问题

# 死锁

* 死锁产生需同时满足的四个条件
  * 互斥
  * 不剥夺
  * 请求并保持
  * 循环等待

# 内存管理

## -虚拟内存

* 不同进程的虚拟地址和不同内存的物理地址映射
* 虚拟地址（VA）---> **内存管理单元（MMU）** ---> [映射到]物理地址（PA）

* 管理方式：内存分段和**内存分页**
* 内存分段：
  * 段表：段号、段基地址、段界限
  * 问题：内存碎片、交换效率低s
* 内存分页
  * 把整个虚拟和物理内存空间分为若干页
  * 每一页4kb
  * 换出换入 swap out / swap in
  * ![1](_img/OS/page.png "页")
  * **页表**：页号、页内偏移
  * 多级页表
    * 解决页表过大的问题
  * **TLB**-Translation Lookaside Buffer
    * 页表缓存，局部性原理
* **段页式内存管理**
  * 段号、段内页号和页内位移
  * 第一次访问段表，得到页表起始地址；
  * 第二次访问页表，得到物理页号；
  * 第三次将物理页号与页内位移组合，得到物理地址。
  * ![1](_img/OS/seg-page.png "段页")

## -Linux内存管理

* ![1](_img/OS/linux-mem.png " " )

* 程序文件段 .text
  * 包括二进制可执行代码
* 已初始化数据段 .data
  * 包括静态常量
* 未初始化数据段 .dbss
  * 包括未初始化的静态变量
* 堆段
  * 包括动态分配的内存，从低地址开始向上增长
* 文件映射段
  * 包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）
* 栈段
  * 包括局部变量和函数调用的上下文等
* 堆和文件映射段的内存动态分配
  * 比如使用C标准库的 malloc() 或 mmap() ，就可以分别在堆和文件映射段动态分配内存。

## -页面置换算法

* OPT 最佳置换算法
  * 无法实现，但作为评价基准
  
* FIFO 先进先出页面置换算法
  * Belady异常

* **LRU 最近最久未使用置换算法**
  * 最新访问放在第一位
  * 缓存满了删除末尾（最不经常访问的数据）
